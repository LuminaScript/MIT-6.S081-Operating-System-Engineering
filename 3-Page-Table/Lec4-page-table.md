# LEC 4 - Page tables & Virtual Memory


> - **Issue:** A shell process has a bug that occasionally writes to random memory addresses.
> - **Solution:** page table allow xv6 to isolate different processâ€™s address spaces and to multiplex them onto a single physical memory.


## 1. Paging Hardware

### Paging Hardware Architecture
![image](https://hackmd.io/_uploads/B1aJ8znLkg.png)
- **CPU:** Generates virtual addresses (VA).
- **MMU:** Kernel configures MMU to map VAs to PAs via page tables (Page Walking).
- **RAM:** Physical memory storage.
- **Process:** Software interacts with virtual addresses.
### Page Walk
![image](https://hackmd.io/_uploads/Sy0xPz2L1x.png)
- **Page Size:** 4KB/4096Bytes (12-bit offset), each has 512 entry
- **Page Table Address:** 64-bit addresses in RISC-V used by xv6.
- **Virtual Address**: only the bottom 39 bits of a 64-bit VA are used
- **Page Table Entry (PTE):** (64 bits total)
    - **Physical Page Number (PPN):** Top 44 bits.
    - **Flags:** Low 10 bits (e.g., Present, Writable).
- **Three Level Page Walk**: If any of the three PTEs required to translate an address is not present, the paging hardware raises a page-fault exception, leaving it up to the kernel to handle the exception
- **TLB**: CPU caches page table entries in a Translation Look-aside Buffer (TLB).
- **`satp` register**: To enable hardware to use a page table, the kernel writes the physical address of the root page-table page into the satp register, which is unique to each CPU and used to translate addresses generated by subsequent instructions.
### Flags
![image](https://hackmd.io/_uploads/HkRkdMh8ye.png)
- **PTE_V**: Indicates whether the page table entry (PTE) is present; if not set, a reference causes an exception.
- **PTE_R**: Controls whether the page can be read by instructions.
- **PTE_W**: Controls whether the page can be written to by instructions.
- **PTE_X**: Controls whether the CPU can interpret the page content as executable instructions.
- **PTE_U**: Controls whether user-mode instructions can access the page; if not set, only supervisor mode can access the page.
## 2. xv6 Address Space
> xv6 maintains one page table per process, plus a single page table for kernel's address space
### Kernel Address Space
![image](https://hackmd.io/_uploads/H17LcGnLye.png)
- **Below `KERNBASE` (direct mapping):** Reserved for I/O devices and boot resources.  
- **`KERNBASE` ~ `PHYSTOP` (direct mapping):** Maps the kernel itself and free physical memory directly.  
- **`PHYSTOP` ~ `MAXVA` (indirect mapping):**  
  - **Double-Mapped Trampoline:** A physical page holding trampoline code is mapped twice in the kernel's virtual address space:  
    - At the top of the virtual address space for user-to-kernel transitions.  
    - With direct mapping for kernel execution.  
    - Trampoline mapping uses `PTE_R` and `PTE_X`, while other kernel pages use `PTE_R` and `PTE_W`.  
  - **Kernel Stacks:** Each process has its own kernel stack mapped high, with an unmapped guard page below.  
    - The guard page's invalid PTE (`PTE_V` unset) ensures that stack overflows cause an exception and kernel panic, protecting other kernel memory.  


### Per-Process Address Space

- **Unique Page Tables:** Each process has its own page table.
- **Switching:** Kernel updates the `satp` register to switch page tables during context switches.
- **Memory Layout:**
    - **User Space:** Starts at VA 0, allows heap growth without physical memory fragmentation.
    - **Kernel Space:** Shared across all processes, includes trampoline and trapframe pages for safe transitions.

### Address Space Arrangement Rationale

- **Isolation:** User and kernel address spaces are separated to prevent unauthorized access.
- **Efficiency:** Shared mappings (e.g., trampoline) simplify transitions and enhance security against attacks like Spectre.
- **Flexibility:** Kernel can easily manage and access physical memory.

### Kernel's Use of Virtual Memory

- **Advantages:**
    - Simplifies memory management by leveraging hardware support.
    - Enables advanced features like marking text pages as executable but not writable.
    - Facilitates debugging and security enhancements.

---

## 4. Code Walkthrough

### Kernel Address Space Setup (`kvmmap()`)

- **Functionality:**
    - Maps virtual addresses to physical addresses.
    - Handles specific mappings like CLINT, PLIC, and kernel text.
- **Key Questions:**
    - Address space size and memory usage after initial mappings.
    - Double mapping verification for trampoline.
    - Behavior after setting the `satp` register and executing `sfence_vma()`.

### Page Mapping (`mappages()` in `vm.c`)

- **Arguments:**
    - Top-level page directory, VA range, PA range, permissions.
- **Process:**
    - Align addresses to page boundaries.
    - Iterate through each page-aligned address in the range.
    - Use `walkpgdir` to find and modify PTEs.

### Page Table Walker (`walk()` in `vm.c`)

- **Functionality:**
    - Simulates hardware page table traversal.
    - Extracts relevant bits from VA to navigate through PD levels.
    - Allocates new PD pages if necessary and updates PTEs.

### Process Initialization (`procinit()` in `proc.c`)

- **Tasks:**
    - Allocates a page for each kernel stack.
    - Sets up guard pages to protect against stack overflows.

### User Address Space Setup

- **Functions:**
    - `allocproc()`: Allocates an empty top-level page table.
    - `fork()`: Uses `uvmcopy()` to duplicate the address space.
    - `exec()`: Replaces the process's page table with a new one via `uvmalloc` and `loadseg`.
- **Key Questions:**
    - Understanding specific page table entries and their purposes.

### Heap Management (`sbrk(n)`)

- **Process:**
    - User calls `sbrk(n)` to allocate more heap memory.
    - Kernel allocates physical memory and maps it into the process's address space.
    - Updates the process size and returns the starting address of the new memory.

### Process Growth (`growproc()` in `proc.c`)

- **Functionality:**
    - Handles increasing the process's memory size.
    - Calls `uvmalloc()` to map new memory pages.
    - Updates the `satp` register during context switches to reflect changes.

### Memory Allocation (`uvmalloc()` in `vm.c`)

- **Considerations:**
    - Uses `PGROUNDUP` to align memory addresses.
    - Interfaces with `mappages()` to establish new mappings.

---

## 5. Additional Topics and Q&A

### Indirection Benefits

- **Physical Memory Flexibility:** Non-contiguous physical memory allocation.
- **Advanced Features:** Lazy allocation, copy-on-write, and more.
- **Upcoming Topics:** Exploration of additional VM techniques in future lectures.

### Q&A Highlights

- **Virtual Memory in Kernel:**
    - Standard kernels use virtual memory for convenience, security, and leveraging hardware support.
- **Page Table Size and Efficiency:**
    - Three-level page tables optimize memory usage by allowing sparse mappings.
- **Address Space Configuration:**
    - Ensures isolation between user processes and the kernel, enhancing system stability and security.

---

## Conclusion

This lecture provided a comprehensive overview of virtual memory, focusing on how xv6 implements isolated address spaces using RISC-V's paging hardware. Key concepts include the structure and management of page tables, address space isolation, and the practical aspects of memory allocation and process management within xv6. Understanding these fundamentals is crucial for developing advanced operating system features and ensuring robust memory management.