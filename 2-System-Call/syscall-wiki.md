## how to add (“stub”) a new system call (e.g., `trace`) in the xv64 kernel. 

### 1. Define the System Call Number and Prototype

1. **Assign a System Call Number**  
   In `syscall.h`, define the constant representing the new system call:
   ```c
   #define SYS_trace  22
   ```

2. **Declare the Function Prototype**  
   In `syscall.c` (or the file where the system call prototypes are collected), add the prototype:
   ```c
   extern uint64 sys_trace(void);
   ```

### 2. Implement the Kernel-Side Function

1. **Write the Function Logic**  
   In `sysproc.c` (or another appropriate source file), implement the system call:
   ```c
   uint64
   sys_trace(void)
   {
     int n;
     if(argint(0, &n) < 0)
       return -1;
     myproc()->syscall_mask = n;
     return 0;
   }
   ```

2. **Register the Function in the System Call Table**  
   In `syscall.c` (or equivalent), locate the system call dispatch table, which is an array of function pointers. Add a mapping from `SYS_trace` to `sys_trace`:
   ```c
   static uint64 (*syscalls[])(void) = {
     [SYS_fork]    sys_fork,
     [SYS_exit]    sys_exit,
     [SYS_wait]    sys_wait,
     ...
     [SYS_trace]   sys_trace
   };
   ```

### 3. Provide a User-Space Stub/Wrapper

1. **Add an Entry in `usys.S`**  
- In xv64, **`usys.S` is generated by the `usys.pl` script.** This script prints out the assembly instructions that define a simple “stub” function for each system call (e.g., `fork`, `exit`, `wait`, etc.).
    #### Example output of `usys.pl`
    ```
    entry("trace");
    ```
    #### Example Output of `usys.S`
    ```assembly
    .global fork
    fork:
        li a7, SYS_fork  # Load the syscall number into register a7
        ecall            # Perform the system call
        ret              # Return to the caller
    ```

    #### How `usys.S` Functions as Syscall Stubs
    1. **Global Function Symbol**  
       The line `.global fork` makes `fork` visible as a symbol that can be called from C code or other parts of the program.
    2. **Load the System Call Number**  
       `li a7, SYS_fork` loads the integer constant corresponding to the system call (e.g., `SYS_fork`) into register `a7` (the RISC-V ABI register designated for system call numbers).
    3. **Trigger the System Call**  
       `ecall` is the RISC-V instruction to enter the kernel.  
       The kernel trap handler sees that `a7` holds `SYS_fork` and then dispatches to the appropriate kernel function (`sys_fork`).
    4. **Return to User Space**  
       After the kernel finishes handling the system call, the processor eventually returns from the trap/interrupt.  
       The stub uses `ret` to return to user code. Whatever value the kernel places in the return register (`a0` on RISC-V) is returned to the user program as the result of `fork()`.

2. **Declare the User-Space Function in a Header**  
In a user-accessible header (e.g., `user.h`), declare the function prototype:

    ```c
    int trace(int);
    ```

    Now, user programs can call `trace(n)` to invoke the new `trace` system call.
